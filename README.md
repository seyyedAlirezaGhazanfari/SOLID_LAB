# گام ۱

<table dir='rtl'>
<tbody>
<tr>
<td width="64">
<p><strong>ردیف</strong></p>
</td>
<td width="198">
<p><strong>محل اعمال تغییرات (کلاس/واسط)</strong></p>
</td>
<td width="141">
<p><strong>عنوان تغییر</strong></p>
</td>
<td width="292">
<p><strong>شرحی کوتاه از تغییر</strong></p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۱</strong></p>
</td>
<td width="198">
<p>PhoneOrderService</p>
</td>
<td width="141">
<p>افزودن کلاس پرداخت تلفنی</p>
</td>
<td width="292">
<p>افزودن یک کلاس به این نام و پیاده سازی واسط OrderService در آن به شکلی که دو تابع مربوط به تلفن را پیاده سازی میکنیم و توابع دیگر را با بدنه خالی پیاده میکنیم.</p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۲</strong></p>
</td>
<td width="198">
<p>Order Service</p>
</td>
<td width="141">
<p>افزودن تابع ثبت سفارش تلفتی</p>
</td>
<td width="292">
<p>افزودن یک تابع برای ثبت سفارش تلفنی با نام phoneOrderRegister که signature اش شبیه به بقیه توابع ثبت سفارش در این واسط است.</p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۳</strong></p>
</td>
<td width="198">
<p>Order Service</p>
</td>
<td width="141">
<p>افزودن تابع پرداخت سفارش تلفنی</p>
</td>
<td width="292">
<p>افزودن یک تابع برای پرداخت سفارش تلفنی با نام phoneOrderPayment که signature اش شبیه به بقیه توابع پرداخت سفارش در این واسط است.</p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۴</strong></p>
</td>
<td width="198">
<p>OnlineOrderService</p>
</td>
<td width="141">
<p>افزودن تابع پرداخت سفارش تلفنی</p>
</td>
<td width="292">
<p>این تابع به علت اضافه شدن آن به واسط که در تغییر قبلی توضیح داده شده است باید در این کلاس هم پیاده سازی شود و ما با بدنه خالی آن را پیاده میکنیم.</p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۵</strong></p>
</td>
<td width="198">
<p>OnlineOrderService</p>
</td>
<td width="141">
<p>افزودن تابع ثبت سفارش تلفنی</p>
</td>
<td width="292">
<p>این تابع به علت اضافه شدن آن به واسط که در تغییر قبلی توضیح داده شده است باید در این کلاس هم پیاده سازی شود و ما با بدنه خالی آن را پیاده میکنیم.</p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۶</strong></p>
</td>
<td width="198">
<p>OnSiteOrderService</p>
</td>
<td width="141">
<p>افزودن تابع پرداخت سفارش تلفنی</p>
</td>
<td width="292">
<p>این تابع به علت اضافه شدن آن به واسط که در تغییر قبلی توضیح داده شده است باید در این کلاس هم پیاده سازی شود و ما با بدنه خالی آن را پیاده میکنیم.</p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۷</strong></p>
</td>
<td width="198">
<p>OnSiteOrderService</p>
</td>
<td width="141">
<p>افزودن تابع ثبت سفارش تلفنی</p>
</td>
<td width="292">
<p>این تابع به علت اضافه شدن آن به واسط که در تغییر قبلی توضیح داده شده است باید در این کلاس هم پیاده سازی شود و ما با بدنه خالی آن را پیاده میکنیم.</p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۸</strong></p>
</td>
<td width="198">
<p>Main</p>
</td>
<td width="141">
<p>چک کردن نحوه انتخاب پرداخت کاربر و ثبت سفارش</p>
</td>
<td width="292">
<p>در سه خط چک میکنیم ابتدا که آیا نحوه پرداخت را کاربر ۳ انتخاب کرده است یا خیر. اگر ۳ انتخاب کرده بود آنگاه یک ابجکت از کلاس PhoneOrderService میسازیم و روی آن رفتار ثبت سفارش را انجام میدهیم.</p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۹</strong></p>
</td>
<td width="198">
<p>Main</p>
</td>
<td width="141">
<p>پرداخت سفارش درصورتی که انتخاب کاربر تلفنی باشد.</p>
</td>
<td width="292">
<p>برای این مورد دو خط به این فایل اضافه میکنیم . در خط اول چک میکنیم آیا سفارش ثبت شده باید تلفنی پرداخت شود یا خیر. اگر این شرط پاس شود انگاه رفتار phoreOrderPayment را بر روی ابجکت orderService فراخوانی میکنیم.</p>
</td>
</tr>
</tbody>
</table>

مجموع تعداد تغییرات: ۹

# گام ۲

<table dir='rtl'>
<tbody>
<tr>
<td rowspan="2" width="240">
<p>اصل 1</p>
<p>Single Responsibility</p>
</td>
<td width="95">
<p><strong>موارد تحقق</strong></p>
</td>
<td width="454">
<p> 
کلاس 
Food
را مورد بررسی قرار میدهیم. در گام اول میتوان گفت که Food تنها یک وظیفه برعهده دارد و آن هم این است که یک فاکتور از غذا ایجاد کند با نام و قیمت آن که بنظرم 
functional cohesion
دارد.

</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>
موردی که بررسی میکنیم کلاس Order است. همانطور که میبینید این کلاس به یک لیست از نمونه های food دارد که کمی همین موضوع از قدرت cohesion کم میکند. دو وظیفه بر عهده این کلاس است. رفتار اول تشکیل لیستی از غذاهای سفارش شده است و وظیفه دوم این کلاس این است که در هر زمان که از او سوال شد هزینه سفارش تا ان لحظه را حساب کند. مشخصا این دو وظیفه دو مورد جدا هستند و الزامی نیست تا در یک کلاس باشند پس میتوان این مورد را نقض اصل ۱ در نظر گرفت.
مورد بعدی واسط OrderService و هر سه کلاسی هستند که این واسط را پیاده سازی میکنند. در این موارد ذکر شده تمامی توابع مربوط به ثبت سفارش و پرداخت آن ها در هر نوعی در هر کدام از انها پیاده سازی شده است و واسط هم مشخصا یک وظیفه ندارد.
</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 2</p>
<p>Open-Close Principle (OCP)</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>
مورد مشخصی من ندیدم فقط موردی که در Main از واسط OrderService بجای instantiation از concrete class ها استفاده میکنیم سبب میشود که در آن قسمت از کد حتی با گسترش روش های پرداخت باز هم تغییری ایجاد نشود.
منظورم مشخصا جایی است که orderService 
در Main
init
میشود.
</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>
تمام محتویات پکیج PaymentService موارد نقض این اصل هستند. در همین مثالی که در گام اول به عنوان فیچر به پروژه اضافه کردیم توجه کنید. برای اینکه این سیستم پرداخت را گسترش بدهیم مجبور به تغییر کد در Main و تغییر کد در تمام کلاس های روش های پرداخت قبلی شدیم که این مشخصا ناقضه این اصل است.
</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 3</p>
<p>Liskov Substitution Principle</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>
موردی که این اصل را رعایت کرده است init متغیر orderService در main است که باتوجه به ساختار پکیج PaymentService ما توانسته ایم یک نمونه از واسط تولید کنیم و بعد از نمونه ای از subclass را در آن قرار بدیم.
</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>
من این مورد رو نفهمیدم کانسپت این اصل که نقض بشه کلا شی گرایی زیر سوال میرود ولی اینکه به درستی از آن استفاده نشود را در تابع Main
میتوان دید. در این تابع تا جایی که کلاس های مختلف رو نمونه میسازیم و در ابجکت واسط میریزیم همه چی برطبق اصل است تا جایی که instance of میزنیم و تایپ چک میکنیم و تابع های مختلف رو بر روی یک ابجکت فراخوانی میکنیم. 
</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 4</p>
<p>Interface Segregation Principle</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>
تنها واسطی که ما در این پروژه داریم ناقض این اصل است ولی در موارد ریز تر میتوان گفت که در 
OrderService
و اینکه دو تابع ثبت سفارش و پرداخت سفارش را (برای یکی از انواع) کنار هم داریم یک واسط مینیمال و خوب را ایجاد میکند مورد دیگری که این اصل را محقق کند وجود ندارد. 
</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>
مورد نقض این اصل بسیار واضح است. چند وظیفه بودن و بیش از حد بزرگ بودن واسط OrderService سبب میشود که هر کدام از کلاس های نحوه سفارش مجبور به پیاده سازی توابعی بشوند که اصلا به انها ربطی ندارد و هیچکاه نیز انها فراخوانی نمیشوند.
</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 5</p>
<p>Dependency Inversion Principle</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>&nbsp;به عنوان یک attribute نیست ولی از انجایی که استفاده از OrderService به عنوان یک واسط بجای ساختن نمونه از کلاس های مشخص باعث میشود که در رابطه با این instantiation بتوان گفت که بین کلاس Main و OrderService این قاعده مورد استفاده قرار گرفته است.</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>
۱. اولین جایی که نقض میشود کلاس Order است که یک association داره به کلاس Food در حالی که این دو کلاس هر دو concrete هستند و در صورت نیاز به مثلا ایجاد یک کلاس دیگر برای فروش میوه در کلاس Order به مشکل میخوریم. 
۲. بنظرم نمونه سازی از کلاس Order در کلاس Main هم نمونه ای از نقض این مورد است زیرا مشخصا ممکن است در ادامه پروژه نیاز داشته باشیم تا نوع دیگری سفارش را به عنوان یک کلاس مظرح کنیم در صورتی که در اینجا بصورت concrete نمونه ساخته ایم.
</p>
</td>
</tr>
</tbody>
</table>